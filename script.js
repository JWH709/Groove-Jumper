//TOKEN:
let personalAccessToken = "QclYwHOWDnQzeGlmzPcvVVjXcjjxQTckcCIoxQOT";

//Album pool data:

albumPools = [
  (sunday = [
    [
      {
        submittedBy: "Jack",
        album: "Sountracks for the Blind",
        url: "https://api.discogs.com/masters/8895",
        albumCover:
          "https://i.discogs.com/1kVMCE0M2vRuBUBxpcy5GTHY2cqECn2ur8VGk_jo5JY/rs:fit/g:sm/q:90/h:302/w:340/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTMyOTc5/Ny0xMTAzMTEzMDI3/LmpwZw.jpeg",
      },
      {
        submittedBy: "Jack",
        album: "Songs for the Deaf",
        url: "https://api.discogs.com/masters/3239",
        albumCover:
          "https://i.discogs.com/RrY6_HSWVQPSyV_Y8Nylk7l8d8Fm-44FHIsZIhdGmgw/rs:fit/g:sm/q:40/h:150/w:150/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTM4NDcx/My0xNTIwMjA4MTk1/LTUwMjEuanBlZw.jpeg",
      },
    ],
    [
      {
        submittedBy: "Jack",
        album: "Sea of Worry",
        url: "https://api.discogs.com/masters/1629425",
        albumCover:
          "https://i.discogs.com/Jn_xrC0FW01j6LHZlD1KLFPUs5hvfM9tXD0rIOmH_dU/rs:fit/g:sm/q:90/h:532/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTE0MzQ5/OTY1LTE1NzI4NDI5/NzMtNjExNi5qcGVn.jpeg",
      },
      {
        submittedBy: "Jack",
        album: "Sea of no Cares",
        url: "https://api.discogs.com/masters/662989",
        albumCover:
          "https://i.discogs.com/wZtPZOu41RZN3mvtgU1Qd5xF2qDDH2w5ikzetDq5dZg/rs:fit/g:sm/q:90/h:572/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTUyOTE2/NjYtMTY4NDIyNTE4/MS04OTIxLmpwZWc.jpeg",
      },
    ],
  ]),
  (monday = [
    [
      {
        submittedBy: "Riley",
        album: "Good Kid, Mad City",
        url: "https://api.discogs.com/masters/484590",
        albumCover:
          "https://i.discogs.com/NlmkKrMlFUvKaaW5GUSKFRrMB1snZbF9Zx6_fMUsBtY/rs:fit/g:sm/q:90/h:588/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTM5NzU5/NTMtMTU3MDQwNDUz/Ni01NDY1LmpwZWc.jpeg",
      },
      {
        submittedBy: "Riley",
        album: "Kid A",
        url: "https://api.discogs.com/masters/21501",
        albumCover:
          "https://i.discogs.com/_zg0Us0N_anqCz9hJvFGeRK2v69eDDCxQnHkd7RcgTk/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTc0NzQz/LTE1NDg5MDI2NDMt/Mzg2OS5qcGVn.jpeg",
      },
    ],
    [
      {
        submittedBy: "Riley",
        album: "Big Fish Theory",
        url: "https://api.discogs.com/masters/1200128",
        albumCover:
          "https://i.discogs.com/8jHRj4WwFg-SGF8VYq6FfzGa2pGWwflBA62gZShFrrM/rs:fit/g:sm/q:90/h:500/w:500/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTEwNDU0/OTY4LTE1MDAwMzIx/NDMtNjQwNS5qcGVn.jpeg",
      },
      {
        submittedBy: "Riley",
        album: "Trout Mask Replica",
        url: "https://api.discogs.com/masters/463963",
        albumCover:
          "https://i.discogs.com/CxeVQmJ2DM006onzI_oDbu0s0I7NCH61h8cRngPrwpE/rs:fit/g:sm/q:90/h:600/w:576/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTI2NjU2/OTktMTYxMzk1MDg0/OC02NTQ4LmpwZWc.jpeg",
      },
    ],
  ]),
  (tuesday = [
    [
      {
        submittedBy: "Braden",
        album: "California",
        url: "https://api.discogs.com/masters/1021870",
        albumCover:
          "https://i.discogs.com/vASPy_CtY4GSdD0Sth0InkqFbCg9-hzgceDRYOddL84/rs:fit/g:sm/q:90/h:542/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTg3MTMy/MzAtMTQ2NzE1MzU4/MC0zMTYzLmpwZWc.jpeg",
      },
      {
        submittedBy: "Braden",
        album: "Californiacation",
        url: "https://api.discogs.com/masters/42546",
        albumCover:
          "https://i.discogs.com/CyHLgusU6vKUZ6AZbiWlLpgtKm2mT05k0NdV5LQvMjM/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTEyNjY4/MDQtMTQ2MTI5MDIx/Ni03MDEwLmpwZWc.jpeg",
      },
    ],
    [
      {
        submittedBy: "Ben",
        album: "Ugly but Honest",
        url: "https://api.discogs.com/masters/282690",
        albumCover:
          "https://i.discogs.com/mdIdk0myc4BpSwO4wRiLI5vTEJbvQRaGH7GMCWrWwio/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTYzMDgx/My0xNjA0NzMxMTU3/LTU5NDkuanBlZw.jpeg",
      },
      {
        submittedBy: "Ben",
        album: "A Beautiful Lie",
        url: "https://api.discogs.com/masters/95121",
        albumCover:
          "https://i.discogs.com/W032BPhXc4TF_63t04c81lsrnydZsZEpsNzwiwIpkhg/rs:fit/g:sm/q:90/h:523/w:562/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTE2NzQx/NTctMTQ0MDAzNjU4/MS03Nzk0LmpwZWc.jpeg",
      },
    ],
  ]),
  (wednesday = [
    [
      {
        submittedBy: "Liam",
        album: "Marquee Moon",
        url: "https://api.discogs.com/masters/6202",
        albumCover:
          "https://i.discogs.com/CRbZRWmZLpLIo0wKdsLJArcMd1NvHE8Qyyd1x22roSk/rs:fit/g:sm/q:90/h:599/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTg3NjUz/MDQtMTQ2ODI5Mzk3/NS0zMTc0LmpwZWc.jpeg",
      },
      {
        submittedBy: "Liam",
        album: "...And Don't the Kids Just Love it",
        url: "https://api.discogs.com/masters/42308",
        albumCover:
          "https://i.discogs.com/xR7qjW5ktNqjDwDCTjCC_30bRl7zgjZBeN_QspAmnMo/rs:fit/g:sm/q:90/h:600/w:594/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTgxNzMx/OC0xMzM0NDIzMTc4/LmpwZWc.jpeg",
      },
    ],
    [
      {
        submittedBy: "Liam",
        album: "Pink Flag",
        url: "https://api.discogs.com/masters/50645",
        albumCover:
          "https://i.discogs.com/cknT5IAagyDTJrkxbuC42GhV07djI_2Ca8kooTUF134/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTIyMzM1/NC0xMzgxOTQ3MDg1/LTc4MTMuanBlZw.jpeg",
      },
      {
        submittedBy: "Liam",
        album: "Black Flag",
        url: "https://api.discogs.com/masters/1404382",
        albumCover:
          "https://i.discogs.com/amuFgmvf17rrbrbLOhFM7xT8HYfcwPj6HHnsx753geE/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTQ2OTEy/MzQtMTQyODE2NTE2/OC01NjM3LmpwZWc.jpeg",
      },
    ],
  ]),
  (thursday = [
    [
      {
        submittedBy: "Jordan",
        album: "Finally Rich",
        url: "https://api.discogs.com/masters/701431",
        albumCover:
          "https://i.discogs.com/G0McalaLCoaz5ggjW5lLAZoroiNuK9wewZBV5m0gXJA/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTIxMzQ5/ODI1LTE2Mzk1MDMy/OTAtOTA4MS5qcGVn.jpeg",
      },
      {
        submittedBy: "Jordan",
        album: "Lifestylez Ov Da Poor & Dangerous",
        url: "https://api.discogs.com/masters/53775",
        albumCover: "",
      },
    ],
    [
      {
        submittedBy: "Jordan",
        album: "Dogs On Acid",
        url: "https://api.discogs.com/masters/901897",
        albumCover:
          "https://i.discogs.com/lmeBySeMmv4GdnUsxzsDupMu3bW-DosGYRhfhEm-bGc/rs:fit/g:sm/q:90/h:593/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTc0MzQ1/NzYtMTQ0MTQ1NTA5/Ni0zNDc4LmpwZWc.jpeg",
      },
      {
        submittedBy: "Jordan",
        album: "Cats Under The Stars",
        url: "https://api.discogs.com/masters/344520",
        albumCover:
          "https://i.discogs.com/ZHww7n31Sxt1_aQd1eMWTZ1vd5zVuH6n3IoZ7kb0hvk/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTU0NzMy/MDMtMTM5NjU0MzQ0/Ny05NzgwLmpwZWc.jpeg",
      },
    ],
  ]),
  (friday = [
    [
      {
        submittedBy: "Riley",
        album: "Scream, Aim, Fire",
        url: "https://api.discogs.com/masters/232474",
        albumCover:
          "https://i.discogs.com/rA_DqS8BQ_-4kUTRvDIc0tMi4q1BGB4O7etjNGI7SDM/rs:fit/g:sm/q:90/h:366/w:400/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTIyNzIw/MTktMTI4NDU1MzM0/MS5qcGVn.jpeg",
      },
      {
        submittedBy: "Riley",
        album: "Loveless",
        url: "https://api.discogs.com/masters/5948",
        albumCover:
          "https://i.discogs.com/BX3VaGJBENv-zgHEdez23DDFIVQlaSWGgdr_8hG6dWA/rs:fit/g:sm/q:90/h:280/w:280/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTEyNzYy/Mi0xMjUwMjA4Njc5/LmpwZWc.jpeg",
      },
    ],
    [
      {
        submittedBy: "Nick",
        album: "Tree Of Tongues",
        url: "https://api.discogs.com/masters/3970280",
        albumCover:
          "https://i.discogs.com/JBGv5PVE-_IK5c_0eNhqe3Qa9bKUTB49MtbNTL2asNg/rs:fit/g:sm/q:90/h:300/w:300/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTM5NzAy/ODAtMTM1MDkzNDUy/Mi0zMDE1LmpwZWc.jpeg",
      },
      {
        submittedBy: "Nick",
        album: "Tiger And The Duke",
        url: "https://api.discogs.com/masters/196585",
        albumCover:
          "https://i.discogs.com/5qU9CrBC6PdGHReHzG4p4eYcFO3wOMqd95a-alSDYRU/rs:fit/g:sm/q:90/h:530/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTEwNTkx/MzktMTU1NDMxMTkx/Mi0zOTU0LmpwZWc.jpeg",
      },
    ],
  ]),
  (saturday = [
    [
      {
        submittedBy: "James",
        album: "Triangle",
        url: "https://api.discogs.com/masters/150447",
        albumCover:
          "https://i.discogs.com/HhxmJIAjinJzKVa7fA95Ahfwd9nCfoDUb4_JTqY9RHI/rs:fit/g:sm/q:90/h:587/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTE4NDI1/ODMtMTI0NzE5NDMz/OS5qcGVn.jpeg",
      },
      {
        submittedBy: "James",
        album: "Circles",
        url: "https://api.discogs.com/masters/1669934",
        albumCover:
          "https://i.discogs.com/-Cq1NLkCM-inLcEhOEQTBdY1Sgvg3QkC2-kU_STKDFA/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTIxMDI4/MTQ3LTE2MzcyNDMw/MjEtNTkxMC5qcGVn.jpeg",
      },
    ],
    [
      {
        submittedBy: "James",
        album: "Frances the Mute",
        url: "https://api.discogs.com/masters/9161",
        albumCover:
          "https://i.discogs.com/T_GoAoUfYEmMeCnWT8QriZQV5faHsz41sKdzZIlHVQk/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTQ2MzMz/Ni0xNTUyNTI2NDQ0/LTc0NzEuanBlZw.jpeg",
      },
      {
        submittedBy: "James",
        album: "Speaking in Toungues",
        url: "https://api.discogs.com/masters/39336",
        albumCover:
          "https://i.discogs.com/w3G0LxzwepwIgx7NkozV23OhlQ3j0XZ3WsvHPH6J1DQ/rs:fit/g:sm/q:90/h:595/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTE3MDcx/OS0xNDM3NDU0NzA4/LTQ4OTQuanBlZw.jpeg",
      },
    ],
  ]),
];

//Function for randomizing the album pool:

function randomAlbumPool() {
  let d = new Date();
  let day = d.getDay();
  let date = d.getUTCDate();
  let poolUsed = undefined;
  let pairUsed = undefined;
  switch (day) {
    case 0:
      poolUsed = albumPools[0];
      break;
    case 1:
      poolUsed = albumPools[1];
      break;
    case 2:
      poolUsed = albumPools[2];
      break;
    case 3:
      poolUsed = albumPools[3];
      break;
    case 4:
      poolUsed = albumPools[4];
      break;
    case 5:
      poolUsed = albumPools[5];
      break;
    case 6:
      poolUsed = albumPools[6];
      break;
  }
  if (date > 15) {
    pairUsed = 1;
  } else {
    pairUsed = 0;
  }
  return poolUsed[pairUsed];
}

//I should make the album pool bigger, but before I do that I should get the app working from one of these two points

function getRandomStartPointer(albumPair) {
  let pointer = Math.round(Math.random() * (1 - 0) + 0);
  if (pointer == 1) {
    let album = albumPair[0].url;
    document.getElementById("album-cover").src = albumPair[0].albumCover;
    return album;
  } else {
    let album = albumPair[1].url;
    document.getElementById("album-cover").src = albumPair[1].albumCover;
    return album;
  }
}

function getMainRelease(results) {
  let target = results.main_release_url;
  fetch(target)
    .then((response) => {
      return response.json();
    })
    .then((results) => {
      // console.log(results); - Check your results at the start
      getFilteredAlbum(results);
      displayCurrentAlbum(albumsGlobal);
      // console.log(albumsGlobal); - Make sure it was added to albumsGlobal correctly
    })
    .catch((error) => {
      console.log(error);
    });
}

//Edit the page to display the start album information:

function displayCurrentAlbum() {
  let albumName = document.getElementById("last-connection-album-title");
  let artistName = document.getElementById("last-connection-artist");
  albumName.innerHTML = albumsGlobal[albumsGlobal.length - 1].album;
  artistName.innerHTML = albumsGlobal[albumsGlobal.length - 1].artists[0].name;
  if (albumsGlobal.length > 1) {
    let match = undefined;
    let connectionName = document.getElementById("last-connection");
    let matchType = infoGlobal.matches[albumsGlobal.length - 1].type;
    if (Array.isArray(infoGlobal.matches[albumsGlobal.length - 1].data)) {
      if (
        infoGlobal.matches[albumsGlobal.length - 1].data[0]?.name == undefined
      ) {
        match = infoGlobal.matches[albumsGlobal.length - 1].data[0];
        connectionName.innerHTML = fixExtraArtists(matchType) + ": " + match;
      } else {
        match = infoGlobal.matches[albumsGlobal.length - 1].data[0].name;
        connectionName.innerHTML = fixExtraArtists(matchType) + ": " + match;
      }
    } else {
      match = infoGlobal.matches[albumsGlobal.length - 1].data;
      connectionName.innerHTML = fixExtraArtists(matchType) + ": " + match;
    }
  }
}

function fixExtraArtists(type) {
  if (type == "extraartists") {
    return "Collaborator";
  } else {
    return type;
  }
}

//create objects to store & reference information globally:

let albumsGlobal = [];
let infoGlobal = {
  connectionsMade: 0,
  matches: [null],
};

//Create consturctors:

function Album(
  albumPosition,
  album,
  artists,
  extraartists,
  labels,
  styles,
  year
) {
  (this.albumPosition = albumPosition),
    (this.album = album),
    (this.artists = artists),
    (this.extraartists = extraartists),
    (this.labels = labels),
    (this.styles = styles),
    (this.year = year);
}

function FilteredArrays(name, id) {
  (this.name = name), (this.id = id);
}

//Create functions that filter the information need for the constructors:

function indexerFilter(currentItem) {
  let filteredResults = new Array();
  for (let i = 0; i < currentItem.length; i++) {
    filteredResults.push(
      new FilteredArrays(currentItem[i].name, currentItem[i].id)
    );
  }
  return filteredResults;
}
function getAlbumCount() {
  if (albumsGlobal.length < 1) {
    return 0;
  } else {
    return albumsGlobal.length;
  }
}
//tracklistartists is getting its own section because A) It's very complicated, B) it's a lot of code:

//The main functionion:

function getTracklistArtists(results) {
  let trackList = results.tracklist;
  let unfilteredResults = new Array();
  for (let i = 0; i < trackList.length; i++) {
    if (trackList[i].extraartists == undefined) {
      unfilteredResults.push("Miss");
    } else {
      for (j = 0; j < trackList[i].extraartists.length; j++) {
        unfilteredResults.push(
          new FilteredArrays(
            trackList[i].extraartists[j].name,
            trackList[i].extraartists[j].id
          )
        );
      }
    }
  }
  let somewhatFilteredResults = unfilteredResults.filter(
    filterTracklistArtists
  );
  return somewhatFilteredResults;
}

//Removes entries labeled as "Miss"/tracklists that had no additional artists on them:

function filterTracklistArtists(unfilteredResults) {
  return unfilteredResults !== "Miss";
}

//Merge tracklistartists with extraartists:

function mergeToContributingArtists(extra, tracklist) {
  let contributingArtists = extra.concat(tracklist);
  return contributingArtists;
}

//Functions that will then use the constructors to build an object:

function getFilteredAlbum(parsedJSON) {
  let albumPosition = getAlbumCount();
  let album = parsedJSON.title;
  let artists = indexerFilter(parsedJSON.artists);
  let extraartists = indexerFilter(parsedJSON.extraartists);
  let tracklistArtists = getTracklistArtists(parsedJSON);
  let contributingArtists = mergeToContributingArtists(
    extraartists,
    tracklistArtists
  );
  let labels = indexerFilter(parsedJSON.labels);
  let styles = parsedJSON.styles;
  let year = parsedJSON.year;
  if (albumsGlobal[0] == undefined) {
    albumsGlobal.pop();
    albumsGlobal.push(
      new Album(
        albumPosition,
        album,
        artists,
        contributingArtists,
        labels,
        styles,
        year
      )
    );
  } else {
    return new Album(
      albumPosition,
      album,
      artists,
      contributingArtists,
      labels,
      styles,
      year
    );
  }
}

//Search functions for Discogs database:

//Add functionality to the search bar

const searchBarAlbumInput = document.getElementById("search-input-album");
const searchBarArtistInput = document.getElementById("search-input-artist");

searchBarAlbumInput.addEventListener("keydown", function (e) {
  if (e.code === "Enter") {
    resetSearchResults();
    searchAlbumAndArtist();
    document.getElementById("search-input-album").value = "";
    document.getElementById("search-input-artist").value = "";
  }
});
searchBarArtistInput.addEventListener("keydown", function (e) {
  if (e.code === "Enter") {
    resetSearchResults();
    searchAlbumAndArtist();
    document.getElementById("search-input-album").value = "";
    document.getElementById("search-input-artist").value = "";
  }
});

//function for searching:

function searchAlbumAndArtist() {
  let albumValueCheck = searchBarAlbumInput.value; //string literals
  let artistValueCheck = searchBarArtistInput.value;
  if (albumValueCheck == "") {
  } else {
    albumValueCheck = "release_title=" + searchBarAlbumInput.value + "&";
  }
  if (artistValueCheck == "") {
    //!
  } else {
    artistValueCheck = "artist=" + searchBarArtistInput.value + "&";
  }
  let formats = ["Album", "EP"];
  let currentFormat = "";
  for (i = 0; i < formats.length; i++) {
    currentFormat = "format=" + formats[i] + "&";
    fetch(
      "https://api.discogs.com/database/search?" +
        albumValueCheck +
        artistValueCheck +
        currentFormat +
        "type=master&per_page=20&page=1&token=QclYwHOWDnQzeGlmzPcvVVjXcjjxQTckcCIoxQOT"
    )
      .then((response) => {
        return response.json();
      })
      .then((results) => {
        // console.log(results); check to see if results were returned correctly
        displaySearchResults(results);
      });
  }
}

//Need to put results on the page:

function displaySearchResults(results) {
  let parent = document.getElementById("search-results-ul");
  for (i = 0; i < results.results.length; i++) {
    let formats = results.results[i].format;
    Check: for (j = 0; j < formats.length; j++) {
      if (
        formats[j] == "Single" ||
        formats[j] == "Compilation" ||
        formats[j] == "Unofficial Release"
      ) {
      } else {
        let newResult = document.createElement("li");
        newResult.innerHTML = results.results[i].title;
        newResult.className = "search-result-li";
        newResult.title = results.results[i].title;
        eventListenerWrapper(results, newResult, i);
        parent.appendChild(newResult);
        break Check;
      }
    }
  }
}

function eventListenerWrapper(results, child, key) {
  child.addEventListener("click", function () {
    let coverArt = results.results[key].thumb;
    resetSearchResults();
    fetch(results.results[key].resource_url)
      .then((response) => {
        return response.json();
      })
      .then((results) => {
        fetch(results.main_release_url)
          .then((response) => {
            return response.json();
          })
          .then((results) => {
            let tempAlbum = getFilteredAlbum(results);
            // console.log(results);
            // console.log(tempAlbum);
            checkForMatches(
              albumsGlobal[albumsGlobal.length - 1],
              tempAlbum,
              coverArt
            );
          })
          .catch((error) => {
            console.log("Search Step 2");
            console.log(error);
          });
      })
      .catch((error) => {
        console.log("Search Step 1: " + error);
      });
  });
}

//function for reseting the search results

function resetSearchResults() {
  let parentListItem = document.getElementById("search-results-ul");
  while (parentListItem.firstChild) {
    parentListItem.removeChild(parentListItem.firstChild);
  }
}

//COMPARISON CODE
//MAIN FUNCTION:

function checkForMatches(currentGlobalAlbum, selectedSearchedAlbum, coverArt) {
  if (compareAlbumTitles(selectedSearchedAlbum)) {
    let textAlert = document.getElementById("failed-match-text");
    textAlert.innerHTML = "Album already used!";
    textAlert.style.display = "flex";
    setTimeout(() => {
      document.getElementById("failed-match-text").style.display = "none";
    }, 5000);
  } else {
    let aritsts = filterComparisonMissesArrays(
      compareArExLa(currentGlobalAlbum.artists, selectedSearchedAlbum.artists)
    );
    let extraartists = filterComparisonMissesArrays(
      compareArExLa(
        currentGlobalAlbum.extraartists,
        selectedSearchedAlbum.extraartists
      )
    );
    let labels = filterComparisonMissesArrays(
      compareArExLa(currentGlobalAlbum.labels, selectedSearchedAlbum.labels)
    );
    let styles = filterComparisonMissesArrays(
      compareStyles(currentGlobalAlbum.styles, selectedSearchedAlbum.styles)
    );
    let year = compareYears(
      currentGlobalAlbum.year,
      selectedSearchedAlbum.year
    );
    let comparedData = new MatchedItems(
      aritsts,
      extraartists,
      labels,
      styles,
      year
    );
    getMatchUsed(
      comparedData,
      infoGlobal.matches,
      selectedSearchedAlbum,
      coverArt
    );
    filterComparisonMissesArrays(albumsGlobal);
    displayCurrentAlbum(selectedSearchedAlbum);
  }
}

//The function for rejecting an album if it's the same as the one being compared against:

function compareAlbumTitles(searchedAlbum) {
  for (i = 0; i < albumsGlobal.length; i++) {
    if (searchedAlbum.album == albumsGlobal[i].album) {
      return true;
    } else {
      return false;
    }
  }
}

//The following code is used for comparing the temp album with the current album

function compareArExLa(currentAlbum, searchedAlbum) {
  if (currentAlbum == undefined || searchedAlbum == undefined) {
    return undefined;
  } else {
    let matches = [];
    currentAlbum.forEach((dataItem) => {
      let nestedMatches = compareArrays(dataItem, searchedAlbum);
      matches.push(nestedMatches);
    });
    return matches;
  }
}

//make a function for the compareArExLa .forEach method

function compareArrays(currentAlbumData, searchedAlbumData) {
  for (i = 0; i < searchedAlbumData.length; i++) {
    if (currentAlbumData.id == searchedAlbumData[i].id) {
      let matches = [];
      let match = searchedAlbumData[i];
      matches.push(match);
      return matches;
    } else {
    }
  }
}

//make a function for comparing styles:

function compareStyles(currentAlbum, searchedAlbum) {
  if (currentAlbum == undefined || searchedAlbum == undefined) {
    return undefined;
  } else {
    let matches = [];
    currentAlbum.forEach((currentAlbum) => {
      let nestedData = compareStylesArrays(currentAlbum, searchedAlbum);
      matches.push(nestedData);
    });
    return matches;
  }
}

//make a function for the compareStyles .forEach method:

function compareStylesArrays(currentArray, secondArray) {
  if (currentArray != undefined && secondArray != undefined) {
    for (i = 0; i < secondArray.length; i++) {
      if (currentArray == secondArray[i]) {
        let matches = [];
        let match = secondArray[i];
        matches.push(match);
        return matches;
      } else {
      }
    }
  }
}

//make a function for comparing years:

function compareYears(currentAlbum, searchedAlbum) {
  if (currentAlbum == searchedAlbum) {
    return currentAlbum;
  } else {
    return undefined;
  }
}

//make a function for filtering out misses

function filterComparisonMissesArrays(targetArray) {
  if (targetArray != undefined) {
    for (i = 0; i < targetArray.length; i++) {
      if (targetArray[i] == undefined) {
        targetArray.splice(i, 1);
        i = 0;
      }
    }
    return targetArray;
  }
}

//make a constructor for returning the matches

function MatchedItems(artists, extraartists, labels, styles, year) {
  (this.artists = artists),
    (this.extraartists = extraartists),
    (this.labels = labels),
    (this.styles = styles),
    (this.year = year);
}

//Make a function that establishes a hierarchy of matches and returns the first match according to where it ranks in said hierarchy
//need to include the check to see if a match is used more than three times here:
//this is the ugly one this time:

function getMatchUsed(
  matchedItemsObject,
  globalMatches,
  fullAlbumData,
  coverArt
) {
  Loop: for (const property in matchedItemsObject) {
    let targetPropertyValue = matchedItemsObject[property];
    if (Array.isArray(targetPropertyValue)) {
      for (i = 0; i < targetPropertyValue.length; i++) {
        if (targetPropertyValue[i] != undefined) {
          let newMatch = new MatchUsed(property, targetPropertyValue[i]);
          let permission = isMatchBlocked(globalMatches, newMatch);
          if (permission == true) {
            infoGlobal.matches.push(newMatch);
            albumsGlobal.push(fullAlbumData);
            infoGlobal.connectionsMade++;
            displayPastConnections();
            document.getElementById("timer").innerHTML = 30;
            document.getElementById("score-display").innerHTML =
              infoGlobal.connectionsMade;
            document.getElementById("album-cover").src = coverArt;
            break Loop;
          } else {
            let textAlert = document.getElementById("failed-match-text");
            textAlert.innerHTML =
              newMatch.type +
              ": " +
              newMatch.data[0].name +
              " has already been used 3 times!";
            textAlert.style.display = "flex";
            setTimeout(() => {
              document.getElementById("failed-match-text").style.display =
                "none";
            }, 5000);
            break Loop;
          }
        }
      }
    } else {
      if (targetPropertyValue == undefined) {
        alert("No Matches Found!");
      } else {
        let newMatch = new MatchUsed(property, targetPropertyValue);
        let permission = isMatchBlocked(globalMatches, newMatch);
        if (permission == true) {
          infoGlobal.matches.push(newMatch);
          albumsGlobal.push(fullAlbumData);
          infoGlobal.connectionsMade++;
          displayPastConnections();
          document.getElementById("timer").innerHTML = 30;
          document.getElementById("score-display").innerHTML =
            infoGlobal.connectionsMade;
          break Loop;
        } else {
          let textAlert = document.getElementById("failed-match-text");
          textAlert.innerHTML =
            newMatch.type +
            ": " +
            newMatch.data[0].name +
            " has already been used 3 times!";
          textAlert.style.display = "flex";
          setTimeout(() => {
            document.getElementById("failed-match-text").style.display = "none";
          }, 5000);
          break Loop;
        }
      }
    }
  }
}

function MatchUsed(type, data) {
  (this.type = type), (this.data = data);
}
//Check to see if a connection has been used already, and how many times it's been used. If used less than 3 times, return true, else return false:

function isMatchBlocked(currentMatches, attemptedMatch) {
  let boolean = undefined;
  let occurances = [];
  for (i = 0; i < currentMatches.length; i++) {
    if (currentMatches[i] != null) {
      switch (attemptedMatch.type) {
        case "artists":
        case "extraartists":
        case "labels":
          if (currentMatches[i].data[0].id == attemptedMatch.data[0].id) {
            occurances.push(attemptedMatch.data[0].id);
            break;
          }
        case "year":
        case "styles":
          if (currentMatches[i].data == attemptedMatch.data) {
            occurances.push(attemptedMatch.data);
            break;
          }
      }
    }
  }
  boolean = strikes(occurances.length);
  occurances = [];
  return boolean;
}

//function for strike system, to be used in isMatchBlocked:

function strikes(numberOfStrikes) {
  let strikeOne = document.getElementById("strike-image-1");
  let strikeTwo = document.getElementById("strike-image-2");
  let strikeThree = document.getElementById("strike-image-3");
  let boolean = undefined;
  switch (numberOfStrikes) {
    case 0:
      strikeOne.style.display = "inline";
      strikeTwo.style.display = "none";
      strikeThree.style.display = "none";
      boolean = true;
      break;
    case 1:
      strikeOne.style.display = "inline";
      strikeTwo.style.display = "inline";
      strikeThree.style.display = "none";
      boolean = true;
      break;
    case 2:
      strikeOne.style.display = "inline";
      strikeTwo.style.display = "inline";
      strikeThree.style.display = "inline";
      boolean = true;
      break;
    case 3:
      strikeOne.style.display = "inline";
      strikeTwo.style.display = "inline";
      strikeThree.style.display = "inline";
      boolean = false;
      break;
  }
  return boolean;
}

//Code pretaining to game start and game end:

//Timer function:

function timerFunctionality() {
  let timer = document.getElementById("timer");
  timer.innerHTML = 30;
  setInterval(function () {
    if (timer.innerHTML == 0) {
      clearInterval(timerFunctionality);
      gameOver();
    } else {
      timer.innerHTML = timer.innerHTML - 1;
    }
  }, 1000);
}

//function for the timer running out:

function gameOver() {
  albumsGlobal = [];
  infoGlobal.connectionsMade = 0;
  infoGlobal.matches = [null];
  document.getElementById("wrapper-hide-on-start").style.display = "none";
  document.getElementById("button-game-start").style.display = "inline";
  document.getElementById("last-connection").innerHTML = "";
  document.getElementById("strike-image-1").style.display = "none";
  document.getElementById("strike-image-2").style.display = "none";
  document.getElementById("strike-image-3").style.display = "none";
  resetSearchResults();
}

//Main game start function via button game start:

document
  .getElementById("button-game-start")
  .addEventListener("click", function () {
    let albumPair = randomAlbumPool();
    fetch(getRandomStartPointer(albumPair))
      .then((response) => {
        return response.json();
      })
      .then((jsonObj) => {
        getMainRelease(jsonObj);
        if (document.getElementById("timer").innerHTML == 30) {
          timerFunctionality();
        } else {
          document.getElementById("timer").innerHTML = 30;
        }
        clearPastConnections();
        document.getElementById("wrapper-hide-on-start").style.display = "flex";
        document.getElementById("button-game-start").style.display = "none";
        document.getElementById("score-display").innerHTML = 0;
      })
      .catch((error) => {
        console.log(error);
      });
  });

//Past connections function

function displayPastConnections() {
  let parent = document.getElementById("history-display");
  let newEntry = document.createElement("ul");
  newEntry.className = "past-connection-album-title";
  newEntry.innerHTML = albumsGlobal[infoGlobal.connectionsMade].album;
  let entryLink = document.createElement("li");
  entryLink.className = "past-connection-title";
  entryLink.innerHTML =
    "From " +
    albumsGlobal[infoGlobal.connectionsMade - 1].album +
    " via " +
    fixExtraArtists(infoGlobal.matches[infoGlobal.connectionsMade].type) +
    ": " +
    connectionType();
  newEntry.title = newEntry.innerHTML;
  entryLink.title = entryLink.innerHTML;
  newEntry.appendChild(entryLink);
  parent.appendChild(newEntry);
}

function connectionType() {
  returnedString = "";
  switch (infoGlobal.matches[infoGlobal.connectionsMade].type) {
    case "artists":
    case "extraartists":
    case "labels":
      returnedString =
        infoGlobal.matches[infoGlobal.connectionsMade].data[0].name;
      break;
    case "styles":
    case "year":
      returnedString = infoGlobal.matches[infoGlobal.connectionsMade].data;
      break;
  }
  return returnedString;
}
//clear past connections on gamer start:

function clearPastConnections() {
  let pastConnections = document.getElementById("history-display");
  if (pastConnections.children.length > 0) {
    while (pastConnections.firstChild) {
      pastConnections.removeChild(pastConnections.firstChild);
    }
  }
}
